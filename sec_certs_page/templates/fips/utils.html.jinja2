{% from "common/entry.html.jinja2" import keywords_card %}

{% macro cryptography_keywords(keyword_scan, doc_prefix, hidden=[], map_funcs={}) -%}
    {{ keywords_card(keyword_scan, doc_prefix, "crypto", "Cryptography", {"Symmetric Algorithms": "symmetric_crypto",
                                                                          "Asymmetric Algorithms": "asymmetric_crypto",
                                                                          "Post-quantum Algorithms": "pq_crypto",
                                                                          "Hash functions": "hash_function",
                                                                          "Schemes": "crypto_scheme",
                                                                          "Protocols": "crypto_protocol",
                                                                          "Randomness": "randomness",
																		  "Engines": "crypto_engine",
																		  "Libraries": "crypto_library",
																		  "Elliptic Curves": "ecc_curve",
																		  "Block cipher modes": "cipher_mode",
																		  "TLS cipher suites": "tls_cipher_suite"}, hidden, map_funcs) }}
{%- endmacro %}

{% macro device_keywords(keyword_scan, doc_prefix, hidden=[], map_funcs={}) -%}
    {{ keywords_card(keyword_scan, doc_prefix, "device", "Device", {"Device models": "device_model",
																	"JavaCard versions": "javacard_version",
																	"JavaCard API constants": "javacard_api_const",
																	"JavaCard packages": "javacard_package",
																	"Operating System name": "os_name",
																	"CPLC": "cplc_data",
																	"IC data groups": "ic_data_group",
																	"Trusted Execution Environments": "tee_name",
																	"Vendor": "vendor"}, hidden, map_funcs) }}
{%- endmacro %}

{% macro security_keywords(keyword_scan, doc_prefix, hidden=[], map_funcs={}) -%}
    {{ keywords_card(keyword_scan, doc_prefix, "security", "Security", {"Security level": "fips_security_level",
	                                                                    "Side-channel analysis": "side_channel_analysis",
																		"Vulnerabilities": "vulnerability",
																		"Certification process": "certification_process"}, hidden, map_funcs) }}
{%- endmacro %}

{% macro other_keywords(keyword_scan, doc_prefix, hidden=[], map_funcs={}) -%}
    {{ keywords_card(keyword_scan, doc_prefix, "other", "Other", {"Standards": "standard_id",
                                                                  "Technical reports": "technical_report_id"}, hidden, map_funcs) }}
{%- endmacro %}

{% macro render_status(status) %}
    {% if status|lower == "active" %}
        <span class="text-success"><i class="fas fa-check-square"></i> active</span>
    {% elif status|lower == "historical" %}
        <span class="text-warning"><i class="fas fa-times-circle"></i> historical</span>
    {% elif status|lower == "revoked" %}
        <span class="text-danger"><i class="fas fa-exclamation-triangle"></i> revoked</span>
    {% else %}
        <span>{{ status }}</span>
    {% endif %}
{%- endmacro %}

{% macro render_document_type(document_type) %}
    {% if document_type == "report" %}
        <span>Certification Report</span>
    {% elif document_type == "target" %}
        <span>Security Policy</span>
    {% endif %}
{%- endmacro %}

{% macro render_type(name) %}
    <span title="{{ name }}">
        {% set ftype = get_fips_type(name) %}
        {% if ftype %}
            <i class="fas fa-fw {{ ftype['icon'] }}" aria-label="{{ name }}"></i>
        {% endif %}
    </span>
{%- endmacro %}

{% macro render_plot(timeline) %}
    <div class="row mt-4 mb-4">
        <div class="col border ml-3 mr-3">
            <h2>Timeline</h2>
            <span>Matched certificates (monthly)</span>
            <div id="timeline"></div>
        </div>
    </div>

    <script>
        function renderTimeline(timeline) {
            let parser = d3.timeParse("%a, %d %b %Y %H:%M:%S GMT");
            let weekFormatter = d3.timeFormat("%m,%Y");
            let weekParser = d3.timeParse("%m,%Y");
            let data = d3.map(timeline, d => ({date: parser(d)}));
            let extent = d3.extent(data, d => d.date);
            let weekRange = d3.timeWeek.range(extent[0], extent[1]);

            let width = 800;
            let height = 320;
            let margin = {top: 20, right: 30, bottom: 30, left: 40};

            let x = d3.scaleUtc()
                .domain(extent)
                .range([margin.left, width - margin.right]);

            let nested = d3.rollup(data, v => v.length, d => weekFormatter(d.date));
            let base = d3.rollup(weekRange, v => 0, d => weekFormatter(d));

            let y = d3.scaleLinear()
                .domain([0, d3.max(nested, d => d[1])]).nice()
                .range([height - margin.bottom, margin.top]);

            let xAxis = g => g
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0));
            let yAxis = g => g
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).tickFormat(d3.format("d")))
                .call(g => g.select(".domain").remove());
            let line = d3.line()
                .x(d => x(d.week))
                .y(d => y(d.count));

            let full = new d3.InternMap([...base, ...nested]);

            let res = d3.sort(d3.map(full, ([name, value]) => ({week: weekParser(name), count: value})), (d) => d.week);
            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width, height]);

            svg.append("path")
                .attr("fill", "none")
                .attr("stroke", "var(--bs-primary)")
                .attr("stroke-width", 1.5)
                .attr("d", line(res));

            svg.append("g")
                .call(xAxis);

            svg.append("g")
                .call(yAxis);

            d3.select("#timeline").append(() => svg.node());
        }

        let certsData = JSON.parse('{{ timeline|tojson }}');
        renderTimeline(certsData);
    </script>
{%- endmacro %}
