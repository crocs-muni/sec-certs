@startuml DashboardArchitectureV2
skinparam backgroundColor white
skinparam classAttributeIconSize 0
skinparam linetype ortho
skinparam packageStyle rectangle

skinparam packageBorderColor #333333
skinparam packageBackgroundColor #F8F9FA
skinparam classBorderColor #666666
skinparam classBackgroundColor white
skinparam arrowColor #4A90E2
skinparam noteBackgroundColor #FFF3CD
skinparam noteBorderColor #FFEAA7

' Font settings
skinparam defaultFontSize 11
skinparam classFontSize 11
skinparam packageFontSize 12
skinparam titleFontSize 16
skinparam classFontColor black
skinparam packageFontColor #2C3E50
skinparam titleFontColor #2C3E50

title sec-certs.org Dashboard Architecture v2 (Implemented)

package "Application Core" #FFE4B5 {
    class "Flask App" as FlaskApp {
        + run()
        + route_handlers
    }

    class Dash {
        + server : Flask
        + layout : html.Div
        + url_base_pathname : str
        + use_pages : bool
        + suppress_callback_exceptions : bool
        + init_app(app: Flask)
    }
    note right of Dash : Custom Dash Application\nExtends plotly.Dash\nIntegrates with Flask server

    class DashboardLayoutManager {
        + data_service : DataService
        + build_layout() : html.Div
        + register_home_page()
    }
    note bottom of DashboardLayoutManager : Layout Orchestrator\nBuilds app shell\nUses dash.page_container

    class CallbackManager {
        + cc_chart_registry : ChartRegistry
        + register_callbacks(app: Dash)
    }
    note bottom of CallbackManager : Callback Coordinator\nRegisters chart callbacks

    class "init_dashboard()" as Init <<function>> {
        + app : Flask
        + csrf : CSRFProtect
        + bootstrap_components()
        + setup_routing()
    }
    note right of Init : Bootstrap Function\nInitializes dashboard system\nCreates registries & services

    Init ..> Dash : creates
    Init ..> CallbackManager : configures
    Init ..> DashboardLayoutManager : creates
}

package "Route Registration" #E6F3FF {
    class "cc_route" <<module>> {
        + register_pages(app, registries, factory)
        + layout(**kwargs) : html.Div
    }
    note right of "cc_route" : CC Dashboard Page\nLazy filter initialization\nRegisters callbacks

    class "fips_route" <<module>> {
        + register_pages()
        + layout(**kwargs) : html.Div
    }
    note right of "fips_route" : FIPS Dashboard Page\n(Placeholder)

    "cc_route" .up.> Dash : registers with
    "fips_route" .up.> Dash : registers with
}

package "Component Registries" #E6F3FF {
    class ChartRegistry {
        - _charts : Dict[str, BaseChart]
        + register(chart: BaseChart)
        + __getitem__(chart_id: str) : BaseChart
        + __iter__() : Iterator[BaseChart]
    }
    note right of ChartRegistry : Singleton Registry Pattern\nManages chart instances

    class FilterRegistry {
        - _filters : Dict[str, BaseFilter]
        + register(filter: BaseFilter)
        + __getitem__(filter_id: str) : BaseFilter
        + __iter__() : Iterator[BaseFilter]
        + clear()
        + __len__() : int
    }
    note right of FilterRegistry : Singleton Registry Pattern\nManages filter instances
}

package "Chart Components" #E8F5E8 {
    abstract class BaseChart {
        + graph_id : str
        + data_service : DataService
        + color_palette : List[str]
        + chart_type : str
        + available_chart_types : List[str]
        + {abstract} render(data: DataFrame) : dcc.Graph
        + {abstract} register_callback(app: Dash)
        + validate_data(df: DataFrame) : bool
    }
    note bottom of BaseChart : Strategy Pattern\nProtocol: SupportsRegisterCallbacks
    
    class CCCategoryDistribution {
        + graph_id : str
        + render(data: DataFrame) : dcc.Graph
        + register_callback(app: Dash)
    }
    
    class CCCertsPerYear {
        + graph_id : str
        + render(data: DataFrame) : dcc.Graph
        + register_callback(app: Dash)
    }
    
    class CCValidityDuration {
        + graph_id : str
        + render(data: DataFrame) : dcc.Graph
        + register_callback(app: Dash)
    }

    CCCategoryDistribution -up-|> BaseChart
    CCCertsPerYear -up-|> BaseChart  
    CCValidityDuration -up-|> BaseChart
}

package "Filter Components" #F0E6FF {
    abstract class BaseFilter {
        + filter_id : str
        + {abstract} render(dataset_type: str) : Component
        + get_state_schema() : dict
    }
    note bottom of BaseFilter : Abstract Filter Interface
    
    class DynamicDropdownFilter {
        + filter_id : str
        + column_name : str
        + options : List[dict]
        + render(dataset_type: str) : dcc.Dropdown
    }
    
    class DynamicTextSearchFilter {
        + filter_id : str
        + column_name : str
        + placeholder : str
        + render(dataset_type: str) : dcc.Input
    }

    class DynamicRangeSliderFilter {
        + filter_id : str
        + column_name : str
        + min_value : float
        + max_value : float
        + render(dataset_type: str) : dcc.RangeSlider
    }

    DynamicDropdownFilter -up-|> BaseFilter
    DynamicTextSearchFilter -up-|> BaseFilter
    DynamicRangeSliderFilter -up-|> BaseFilter
}

package "Filter Factory & Metadata" #F0E6FF {
    class FilterFactory {
        + data_service : DataService
        + detector : FilterTypeDetector
        + get_priority_filters_for_dataset(type: str) : List[ColumnMetadata]
        + create_filter(metadata: ColumnMetadata, id: str) : BaseFilter
    }
    note right of FilterFactory : Factory Pattern\nDynamic filter creation\nLazy initialization

    class FilterTypeDetector {
        + CATEGORICAL_THRESHOLD : int = 50
        + {static} detect_filter_type(column: Series, name: str) : ColumnMetadata
        + {static} _should_skip_column(name: str) : bool
    }
    note right of FilterTypeDetector : Analyzes columns\nDetermines filter type

    enum FilterType {
        DROPDOWN
        TEXT_SEARCH
        RANGE_SLIDER
        DATE_RANGE
        SKIP
    }

    class ColumnMetadata <<dataclass>> {
        + name : str
        + dtype : str
        + filter_type : FilterType
        + unique_count : int
        + null_count : int
        + sample_values : List[Any]
        + min_value : float
        + max_value : float
    }

    FilterFactory o-right-> FilterTypeDetector : uses
    FilterFactory .down.> ColumnMetadata : creates
    FilterFactory .down.> BaseFilter : creates
    FilterTypeDetector .down.> FilterType : uses
    ColumnMetadata o-right-> FilterType : contains
}

package "Data & Persistence Layer" #FFFACD {
    class DataService {
        + mongo : PyMongo
        - _df_cc : DataFrame
        - _df_fips : DataFrame
        + get_cc_dataframe() : DataFrame
        + get_fips_dataframe() : DataFrame
        + get_dataset_metadata(type: str) : Dict
    }
    note right of DataService : Data Access Layer\nIn-memory caching\nLazy data loading

    class PyMongo <<Flask Extension>> {
        + db : Database
        + cx : MongoClient
    }
    note right of PyMongo : MongoDB Connection\nFlask-PyMongo wrapper

    class "MongoDB" <<Database>> {
        + collections: cc, fips
    }

    DataService o-right-> PyMongo : uses
    PyMongo -down-> "MongoDB" : connects to
}

package "Data Models" #F5F5F5 {
    entity DataFrame <<Pandas>> {
        + columns : Index
        + dtypes : Series
        + filter()
        + groupby()
        + pivot_table()
    }
    
    entity Component <<Dash>> {
        + id : str
        + children : List
        + style : dict
    }
}

' Relationships - Application Flow
FlaskApp -right-> Init : initializes

Dash *-down- DashboardLayoutManager : contains
Dash *-down- CallbackManager : contains

DashboardLayoutManager .down.> "cc_route" : registers
DashboardLayoutManager .down.> "fips_route" : registers

"cc_route" o.right.> ChartRegistry : queries
"cc_route" o.right.> FilterRegistry : queries
"cc_route" o.down.> FilterFactory : uses (lazy init)

CallbackManager o-down-> ChartRegistry : iterates

' Registry relationships
ChartRegistry o-down- "1..*" BaseChart : stores
FilterRegistry o-down- "1..*" BaseFilter : stores

' Data flow
BaseChart o-right-> DataService : fetches data
FilterFactory o-left-> DataService : queries metadata

' Output relationships
BaseChart .down.> Component : creates
BaseFilter .down.> Component : creates
DataService -down-> DataFrame : provides

' Notes on implementation details
note bottom of Init
    Initialization sequence:
    1. Create DataService
    2. Create ChartRegistry & FilterRegistry
    3. Instantiate and register charts
    4. Create FilterFactory (filters created on-demand)
    5. Create Dash app with use_pages=True
    6. Register routes (cc_route, fips_route)
    7. Register home page
    8. Set layout with dash.page_container
end note

note bottom of "cc_route"
    Lazy Filter Initialization:
    - Filters created on first page visit
    - Uses FilterFactory.get_priority_filters_for_dataset()
    - Registers created filters to FilterRegistry
    - Callbacks registered per-chart basis
end note

@enduml
