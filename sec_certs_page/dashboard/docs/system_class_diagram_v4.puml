@startuml DashboardArchitectureV4Corrected
skinparam backgroundColor white
skinparam classAttributeIconSize 0
skinparam linetype ortho
skinparam packageStyle rectangle

skinparam packageBorderColor #333333
skinparam packageBackgroundColor #F8F9FA
skinparam classBorderColor #666666
skinparam classBackgroundColor white
skinparam arrowColor #4A90E2
skinparam noteBackgroundColor #FFF3CD
skinparam noteBorderColor #FFEAA7

skinparam defaultFontSize 11
skinparam classFontSize 11
skinparam packageFontSize 12
skinparam titleFontSize 16

title sec-certs.org Dashboard Architecture v4 - Corrected

package "Application Core" #FFE4B5 {
    class "Flask App" as FlaskApp {
        + run()
    }

    class Dash {
        + server : Flask
        + layout : html.Div
        + url_base_pathname : str
    }

    class "init_dashboard()" as Init <<function>> {
        + app : Flask
        + csrf : CSRFProtect
        + returns : Dash
    }
}

package "Dashboard Management" #E6FFE6 {
    class DashboardManager {
        + data_service : DataService
        + repository : DashboardRepository
        + chart_registries : dict[CollectionName, ChartRegistry]
        + filter_factories : dict[CollectionName, FilterFactory]
        + get_chart_registry(collection_name) : ChartRegistry
        + get_filter_factory(collection_name) : FilterFactory
        + create_dashboard(...) : Dashboard
        + save_dashboard(dashboard) : str
        + load_dashboard(dashboard_id) : Dashboard
        + load_dashboard_with_charts(dashboard_id) : tuple[Dashboard, list[BaseChart]]
        + get_predefined_chart_configs(collection_name) : list[ChartConfig]
        + delete_dashboard(dashboard_id, user_id) : bool
    }

    class DashboardRepository {
        + collection : Collection
        + save(dashboard: Dashboard) : str
        + get_by_id(dashboard_id: str) : Dashboard | None
        + get_by_user(user_id: str, collection_name: str) : list[Dashboard]
        + get_default(user_id: str, collection_name: str) : Dashboard | None
        + delete(dashboard_id: str) : bool
        + count_by_user(user_id: str, collection_name: str) : int
    }

    DashboardManager o--> DashboardRepository
}

package "Domain Models" #E8F5E8 {
    class Dashboard <<dataclass>> {
        + dashboard_id : str
        + user_id : str
        + collection_name : CollectionName
        + name : str
        + charts : list[ChartConfig]
        + is_default : bool
        + created_at : datetime
        + updated_at : datetime
        + add_chart(chart: ChartConfig)
        + remove_chart(chart_id: str)
        + get_chart(chart_id: str) : ChartConfig | None
        + to_dict() : dict
        + {static} from_dict(data: dict) : Dashboard
    }

    class ChartConfig <<dataclass>> {
        + chart_id : UUID
        + name : str
        + chart_type : ChartType
        + x_axis : AxisConfig
        + collection_name : CollectionName
        + title : str
        + order : int
        + y_axis : AxisConfig | None
        + color_axis : AxisConfig | None
        + filters : dict[str, FilterSpec]
        + filter_values : dict[str, Any]
        + query_pipeline : list[dict[str, Any]] | None
        + color_scheme : str
        + show_legend : bool
        + show_grid : bool
        + is_editable : bool
        + created_at : datetime | None
        + updated_at : datetime | None
        + add_filter(filter: FilterSpec)
        + remove_filter(filter_id: str)
        + get_active_filters() : dict[str, FilterSpec]
        + to_dict() : dict
        + to_client_dict() : dict
        + {static} from_dict(data: dict) : ChartConfig
    }

    class AxisConfig <<dataclass>> {
        + field : str
        + label : str
        + aggregation : AggregationType | None
        + to_dict() : dict
        + {static} from_dict(data: dict) : AxisConfig
    }

    Dashboard *--> "0..*" ChartConfig
    ChartConfig *--> "1..3" AxisConfig
    ChartConfig o--> "0..*" FilterSpec
}

package "Type Definitions" #F5F5F5 {
    enum CollectionName <<StrEnum>> {
        CommonCriteria = "cc"
        FIPS140 = "fips"
    }

    enum ChartType <<StrEnum>> {
        BAR = "bar"
        STACKED_BAR = "stacked_bar"
        LINE = "line"
        PIE = "pie"
        SCATTER = "scatter"
        BOX = "box"
        HISTOGRAM = "histogram"
    }

    enum AggregationType <<StrEnum>> {
        COUNT = "count"
        SUM = "sum"
        AVG = "avg"
        MIN = "min"
        MAX = "max"
    }
}

package "Chart Components" #E8F5E8 {
    abstract class BaseChart <<dataclass>> {
        + config : ChartConfig
        + {property} id : str
        + {property} {abstract} title : str
        + {abstract} render(data_service, filter_values) : Component
        # _render_empty_state(message) : Alert
        # _render_error_state(message) : Alert
        # _render_container(children) : html.Div
        # _create_graph_component(figure) : dcc.Graph
        # _create_config_store() : dcc.Store
        # _get_merged_filter_values(dashboard_filters) : dict
    }

    class ConfigurableChart <<abstract>> {
        + render(data_service, filter_values) : Component
        # _get_aggregated_data(data_service, filter_values) : DataFrame
    }
    note right of ConfigurableChart
        Intermediate class providing
        common data fetching and
        FigureBuilder integration.
    end note

    class BarChartComponent {
        + {property} title : str
    }

    class LineChartComponent {
        + {property} title : str
    }

    class PieChartComponent {
        + {property} title : str
    }

    class ScatterChartComponent {
        + {property} title : str
    }

    class BoxChartComponent {
        + {property} title : str
    }

    class HistogramChartComponent {
        + {property} title : str
    }

    class ErrorChart {
        + error_message : str
        + _title : str
        + render(data_service, filter_values) : Component
    }

    ConfigurableChart --|> BaseChart
    BarChartComponent --|> ConfigurableChart
    LineChartComponent --|> ConfigurableChart
    PieChartComponent --|> ConfigurableChart
    ScatterChartComponent --|> ConfigurableChart
    BoxChartComponent --|> ConfigurableChart
    HistogramChartComponent --|> ConfigurableChart
    ErrorChart --|> BaseChart
}

package "Component Registries & Factory" #E6F3FF {
    class ChartRegistry {
        + collection_name : CollectionName
        - _predefined_charts : dict[str, BaseChart]
        + register(chart: BaseChart)
        + get_predefined(chart_id: str) : BaseChart | None
        + __getitem__(chart_id: str) : BaseChart
        + __iter__() : Iterator[BaseChart]
    }
    note right of ChartRegistry
        Only stores predefined (built-in) charts.
        Custom charts are created on-demand from
        chart_configs (dcc.Store) to support
        multi-worker deployments.
    end note

    class ChartFactory {
        - {static} _chart_classes : dict[ChartType, type[BaseChart]]
        + {static} create_chart(config: ChartConfig) : BaseChart
    }

    class FigureBuilder {
        + {static} create_figure(config: ChartConfig, df: DataFrame) : go.Figure
        + {static} create_figure_from_aggregated(config: ChartConfig, df: DataFrame) : go.Figure
        - {static} _create_bar_chart(config, df) : go.Figure
        - {static} _create_line_chart(config, df) : go.Figure
        - {static} _create_pie_chart(config, df) : go.Figure
        - {static} _create_scatter_chart(config, df) : go.Figure
        - {static} _create_box_chart(config, df) : go.Figure
        - {static} _create_histogram(config, df) : go.Figure
    }

    ChartRegistry o--> "0..*" BaseChart
    ChartFactory ..> BaseChart : creates
    ChartFactory ..> ChartConfig : reads
    FigureBuilder ..> ChartConfig : reads
    ConfigurableChart ..> FigureBuilder : uses
}

package "Filter System" #F0E6FF {
    enum FilterOperator <<StrEnum>> {
        EQ = "$eq"
        NE = "$ne"
        GT = "$gt"
        GTE = "$gte"
        LT = "$lt"
        LTE = "$lte"
        IN = "$in"
        NIN = "$nin"
        REGEX = "$regex"
        EXISTS = "$exists"
        YEAR_IN = "$year_in"
    }

    enum FilterComponentType <<StrEnum>> {
        DROPDOWN = "dropdown"
        MULTI_DROPDOWN = "multi_dropdown"
        TEXT_SEARCH = "text_search"
        DATE_PICKER = "date_picker"
        DATE_RANGE = "date_range"
        CHECKBOX = "checkbox"
    }

    class FilterComponentParams <<dataclass>> {
        + component_type : FilterComponentType
        + label : str
        + placeholder : str | None
        + min_value : int | float | str | None
        + max_value : int | float | str | None
        + default_value : Any | None
        + help_text : str | None
        + multi : bool
        + clearable : bool
        + searchable : bool
    }

    class FilterSpec <<dataclass>> {
        + id : str
        + database_field : str
        + operator : FilterOperator
        + data_type : str
        + component_params : FilterComponentParams
        + active : bool
        + data : Any | None
        + transform : Callable | None
        + mongodb_pipeline : list[dict] | None
        + to_dict() : dict
        + {static} from_dict(data: dict) : FilterSpec
    }

    FilterSpec o--> FilterOperator
    FilterSpec *--> FilterComponentParams
    FilterComponentParams o--> FilterComponentType
}

package "Filter Registries" #F0E6FF {
    abstract class FilterSpecRegistry <<ABC>> {
        + {static} collection_name : CollectionName
        - {static} _filters : dict[str, FilterSpec]
        + {static} get_filter(id: str) : FilterSpec | None
        + {static} get_all_filters() : dict[str, FilterSpec]
        + {static} get_filters_by_component_type(type) : list[FilterSpec]
    }

    class CCFilterRegistry {
        + {static} collection_name : CollectionName = "cc"
        - {static} _filters : dict[str, FilterSpec]
    }

    class FIPSFilterRegistry {
        + {static} collection_name : CollectionName = "fips"
        - {static} _filters : dict[str, FilterSpec]
    }

    CCFilterRegistry --|> FilterSpecRegistry
    FIPSFilterRegistry --|> FilterSpecRegistry
    FilterSpecRegistry o--> "0..*" FilterSpec
}

package "Filter Component Factory" #F0E6FF {
    class FilterFactory {
        + collection_name : CollectionName
        - _registry : type[FilterSpecRegistry]
        + create_filter(filter_spec: FilterSpec) : Component
        + create_all_filters(with_labels: bool) : list[Component]
        + create_filter_panel(title: str, columns: int) : Component
        + get_filter_ids() : list[str]
        + collect_filter_values(*filter_values) : dict[str, Any]
        + get_available_fields() : list[dict]
        + get_numeric_fields() : list[dict]
        + get_filter_specs_for_modal() : list[dict]
    }

    FilterFactory ..> FilterSpec
    FilterFactory ..> FilterSpecRegistry
}

package "Query Builder" #FFE6E6 {
    class QueryBuilder {
        + collection_name : CollectionName
        - _registry : type[FilterSpecRegistry]
        - _query_fragments : list[dict]
        - _errors : list[str]
        + add_filter(filter_id: str, value: Any) : QueryBuilder
        + add_filters(filters: dict[str, Any]) : QueryBuilder
        + build() : dict[str, Any]
        + reset() : QueryBuilder
        + get_errors() : list[str]
        + has_errors() : bool
    }

    class "build_query_from_filters()" as QueryFunc <<function>> {
        + collection_name : CollectionName
        + filter_values : dict[str, Any]
        + returns : dict[str, Any]
    }

    class "build_chart_pipeline()" as ChartPipelineFunc <<function>> {
        + config : ChartConfig
        + filter_values : dict[str, Any]
        + returns : list[dict[str, Any]]
    }

    QueryBuilder ..> FilterSpecRegistry
    QueryFunc ..> QueryBuilder
    ChartPipelineFunc ..> ChartConfig
}

package "Data Layer" #FFFACD {
    class DataService {
        + mongo : PyMongo
        + get_dataframe(collection_name, filter_values) : DataFrame
        + get_cc_dataframe(filter_values) : DataFrame
        + get_fips_dataframe(filter_values) : DataFrame
        + execute_aggregation_pipeline(collection_name, pipeline) : DataFrame
        + get_distinct_values(field, collection_name) : list
        + get_unique_values(collection_name, field) : list
        + get_dataset_metadata(collection_name) : tuple[dict, int, int]
        - _prepare_cc_dataframe(data) : DataFrame
        - _prepare_fips_dataframe(data) : DataFrame
    }

    class PyMongo <<Flask Extension>> {
        + db : Database
    }

    DataService o--> PyMongo
    DataService ..> QueryFunc
    DataService ..> ChartPipelineFunc
}

package "Page Registration" #E6F3FF {
    class "pages" <<module>> {
        + register_pages(app, data_service, manager)
    }

    class "cc_route" <<module>> {
        + layout(**kwargs) : html.Div
    }

    class "fips_route" <<module>> {
        + layout(**kwargs) : html.Div
    }

    class "home_route" <<module>> {
        + layout(**kwargs) : html.Div
    }

    "pages" ..> "cc_route"
    "pages" ..> "fips_route"
    "pages" ..> "home_route"
}

' Main relationships
FlaskApp --> Init
Init ..> DashboardManager : creates
Init ..> Dash : creates
Dash *-- "pages"

DashboardManager o--> ChartRegistry : per collection
DashboardManager o--> FilterFactory : per collection
DashboardManager ..> Dashboard : creates/loads

BaseChart ..> ChartConfig : configured by

"pages" o--> DashboardManager
"pages" o--> DataService

note bottom of Init
    Initialization sequence:
    1. Create DataService (with PyMongo)
    2. Create DashboardRepository
    3. Create DashboardManager
       - ChartRegistry per CollectionName
       - FilterFactory per CollectionName
    4. Create Dash app with Flask server
    5. Register pages (CC, FIPS, Home)
    6. Register callbacks
end note

note right of Dashboard
    Persistence:
    - to_dict() → MongoDB document
    - from_dict() → reconstruct
    - Charts stored as ChartConfig list
    - Filter state preserved
    - Axis configurations included
end note

note bottom of ChartConfig
    Key features:
    - Uses ChartType enum (not AvailableChartTypes)
    - collection_name for multi-dataset support
    - color_axis for grouping/stacking
    - filter_values for dashboard-level filters
    - is_editable for custom vs predefined
    - to_client_dict() for browser-safe serialization
end note

note bottom of FigureBuilder
    Centralizes all Plotly
    figure creation logic.
    Two entry points:
    - create_figure(): from raw data
    - create_figure_from_aggregated():
      from pre-aggregated pipeline results
end note

note bottom of BaseChart
    Abstract base using ABC + @dataclass.
    Signature: render(data_service=None, filter_values=None)
    Both parameters optional to support ErrorChart.
end note

@enduml
