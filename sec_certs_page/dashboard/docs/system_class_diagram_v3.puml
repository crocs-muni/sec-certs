@startuml DashboardArchitectureV3
skinparam backgroundColor white
skinparam classAttributeIconSize 0
skinparam linetype ortho
skinparam packageStyle rectangle

skinparam packageBorderColor #333333
skinparam packageBackgroundColor #F8F9FA
skinparam classBorderColor #666666
skinparam classBackgroundColor white
skinparam arrowColor #4A90E2
skinparam noteBackgroundColor #FFF3CD
skinparam noteBorderColor #FFEAA7

' Font settings
skinparam defaultFontSize 11
skinparam classFontSize 11
skinparam packageFontSize 12
skinparam titleFontSize 16
skinparam classFontColor black
skinparam packageFontColor #2C3E50
skinparam titleFontColor #2C3E50

title sec-certs.org Dashboard Architecture v3 (With QueryBuilder)

package "Application Core" #FFE4B5 {
    class "Flask App" as FlaskApp {
        + run()
        + route_handlers
    }

    class Dash {
        + server : Flask
        + layout : html.Div
        + url_base_pathname : str
        + use_pages : bool
        + suppress_callback_exceptions : bool
        + init_app(app: Flask)
    }
    note right of Dash : Custom Dash Application\nExtends plotly.Dash\nIntegrates with Flask server

    class DashboardLayoutManager {
        + data_service : EnhancedDataService
        + build_layout() : html.Div
        + register_home_page()
    }
    note bottom of DashboardLayoutManager : Layout Orchestrator\nBuilds app shell\nUses dash.page_container

    class CallbackManager {
        + cc_chart_registry : ChartRegistry
        + register_callbacks(app: Dash)
    }
    note bottom of CallbackManager : Callback Coordinator\nRegisters chart callbacks

    class "init_dashboard()" as Init <<function>> {
        + app : Flask
        + csrf : CSRFProtect
        + bootstrap_components()
        + setup_routing()
    }
    note right of Init : Bootstrap Function\nInitializes dashboard system\nCreates registries & services

    Init ..> Dash : creates
    Init ..> CallbackManager : configures
    Init ..> DashboardLayoutManager : creates
}

package "Route Registration" #E6F3FF {
    class "cc_route" <<module>> {
        + register_pages(app, registries, factory)
        + layout(**kwargs) : html.Div
    }
    note right of "cc_route" : CC Dashboard Page\nLazy filter initialization\nRegisters callbacks

    class "fips_route" <<module>> {
        + register_pages()
        + layout(**kwargs) : html.Div
    }
    note right of "fips_route" : FIPS Dashboard Page\n(Placeholder)

    "cc_route" .up.> Dash : registers with
    "fips_route" .up.> Dash : registers with
}

package "Component Registries" #E6F3FF {
    class ChartRegistry {
        - _charts : Dict[str, BaseChart]
        + register(chart: BaseChart)
        + __getitem__(chart_id: str) : BaseChart
        + __iter__() : Iterator[BaseChart]
    }
    note right of ChartRegistry : Singleton Registry Pattern\nManages chart instances

    class FilterRegistry {
        - _filters : Dict[str, BaseFilter]
        + register(filter: BaseFilter)
        + __getitem__(filter_id: str) : BaseFilter
        + __iter__() : Iterator[BaseFilter]
        + clear()
        + __len__() : int
    }
    note right of FilterRegistry : Singleton Registry Pattern\nManages filter instances
}

package "Chart Components" #E8F5E8 {
    abstract class BaseChart {
        + graph_id : str
        + data_service : EnhancedDataService
        + color_palette : List[str]
        + chart_type : str
        + available_chart_types : List[str]
        + {abstract} render(data: DataFrame) : dcc.Graph
        + {abstract} register_callback(app: Dash)
        + validate_data(df: DataFrame) : bool
    }
    note bottom of BaseChart : Strategy Pattern\nProtocol: SupportsRegisterCallbacks
    
    class CCCategoryDistribution {
        + graph_id : str
        + render(data: DataFrame) : dcc.Graph
        + register_callback(app: Dash)
    }
    
    class CCCertsPerYear {
        + graph_id : str
        + render(data: DataFrame) : dcc.Graph
        + register_callback(app: Dash)
    }
    
    class CCValidityDuration {
        + graph_id : str
        + render(data: DataFrame) : dcc.Graph
        + register_callback(app: Dash)
    }

    CCCategoryDistribution -up-|> BaseChart
    CCCertsPerYear -up-|> BaseChart  
    CCValidityDuration -up-|> BaseChart
}

package "Filter Components" #F0E6FF {
    abstract class BaseFilter {
        + filter_id : str
        + {abstract} render(dataset_type: str) : Component
        + get_state_schema() : dict
    }
    note bottom of BaseFilter : Abstract Filter Interface
    
    class DynamicDropdownFilter {
        + filter_id : str
        + column_name : str
        + options : List[dict]
        + render(dataset_type: str) : dcc.Dropdown
    }
    
    class DynamicTextSearchFilter {
        + filter_id : str
        + column_name : str
        + placeholder : str
        + render(dataset_type: str) : dcc.Input
    }

    class DynamicRangeSliderFilter {
        + filter_id : str
        + column_name : str
        + min_value : float
        + max_value : float
        + render(dataset_type: str) : dcc.RangeSlider
    }

    DynamicDropdownFilter -up-|> BaseFilter
    DynamicTextSearchFilter -up-|> BaseFilter
    DynamicRangeSliderFilter -up-|> BaseFilter
}

package "Filter Factory & Metadata" #F0E6FF {
    class FilterFactory {
        + data_service : EnhancedDataService
        + detector : FilterTypeDetector
        + get_priority_filters_for_dataset(type: str) : List[ColumnMetadata]
        + create_filter(metadata: ColumnMetadata, id: str) : BaseFilter
    }
    note right of FilterFactory : Factory Pattern\nDynamic filter creation\nLazy initialization

    class FilterTypeDetector {
        + CATEGORICAL_THRESHOLD : int = 50
        + {static} detect_filter_type(column: Series, name: str) : ColumnMetadata
        + {static} _should_skip_column(name: str) : bool
    }
    note right of FilterTypeDetector : Analyzes columns\nDetermines filter type

    enum FilterType {
        DROPDOWN
        TEXT_SEARCH
        RANGE_SLIDER
        DATE_RANGE
        SKIP
    }

    class ColumnMetadata <<dataclass>> {
        + name : str
        + dtype : str
        + filter_type : FilterType
        + unique_count : int
        + null_count : int
        + sample_values : List[Any]
        + min_value : float
        + max_value : float
    }

    FilterFactory o-right-> FilterTypeDetector : uses
    FilterFactory .down.> ColumnMetadata : creates
    FilterFactory .down.> BaseFilter : creates
    FilterTypeDetector .down.> FilterType : uses
    ColumnMetadata o-right-> FilterType : contains
}

package "Query Builder Layer" #FFE6E6 {
    enum FilterOperator {
        EQ = "$eq"
        NE = "$ne"
        GT = "$gt"
        GTE = "$gte"
        LT = "$lt"
        LTE = "$lte"
        IN = "$in"
        NIN = "$nin"
        REGEX = "$regex"
        EXISTS = "$exists"
    }
    note right of FilterOperator : MongoDB Operators\nUsed in query construction

    class FilterDefinition <<dataclass>> {
        + filter_id : str
        + mongodb_field : str
        + operator : FilterOperator
        + data_type : type
        + transform : Optional[callable]
        + build_query_fragment(value: Any) : Dict
        - _validate_type(value: Any) : bool
    }
    note right of FilterDefinition : Defines filter-to-MongoDB mapping\nBuilds query fragments

    class QueryFilterRegistry {
        + CC_FILTERS : Dict[str, FilterDefinition]
        + FIPS_FILTERS : Dict[str, FilterDefinition]
        + {static} get_filter_definition(id: str, type: str) : FilterDefinition
        + {static} get_all_filters(type: str) : Dict
    }
    note right of QueryFilterRegistry : Central repository\nof filter definitions

    class QueryBuilder {
        + dataset_type : str
        - _query_fragments : List[Dict]
        - _errors : List[str]
        + add_filter(id: str, value: Any) : QueryBuilder
        + add_filters(filters: Dict) : QueryBuilder
        + build() : Dict[str, Any]
        + get_errors() : List[str]
        + reset() : QueryBuilder
    }
    note right of QueryBuilder : Builder Pattern\nConstructs MongoDB queries\nSupports method chaining

    class "build_query_from_filters()" as QueryFunc <<function>> {
        + filter_values : Dict[str, Any]
        + dataset_type : str
        + returns : Dict[str, Any]
    }
    note right of QueryFunc : Convenience function\nfor quick query building

    FilterDefinition o--> FilterOperator : uses
    QueryFilterRegistry o--> FilterDefinition : contains
    QueryBuilder o--> QueryFilterRegistry : queries
    QueryBuilder .down.> FilterDefinition : uses
    QueryFunc ..> QueryBuilder : creates
}

package "Data & Persistence Layer" #FFFACD {
    class EnhancedDataService {
        + mongo : PyMongo
        - _df_cc : DataFrame
        - _df_fips : DataFrame
        + get_cc_dataframe() : DataFrame
        + get_filtered_cc_dataframe(filters: Dict, use_cache: bool) : DataFrame
        + get_fips_dataframe() : DataFrame
        + get_dataset_metadata(type: str) : Dict
        + clear_cache()
        - _prepare_cc_dataframe(data: List) : DataFrame
        - _filter_cached_dataframe(df: DataFrame, filters: Dict) : DataFrame
    }
    note right of EnhancedDataService : Enhanced Data Access Layer\nSupports both cached and filtered queries\nIntegrates QueryBuilder for MongoDB filtering

    class PyMongo <<Flask Extension>> {
        + db : Database
        + cx : MongoClient
    }
    note right of PyMongo : MongoDB Connection\nFlask-PyMongo wrapper

    class "MongoDB" <<Database>> {
        + collections: cc, fips
    }

    EnhancedDataService o-right-> PyMongo : uses
    EnhancedDataService .down.> QueryFunc : uses for filtering
    PyMongo -down-> "MongoDB" : connects to
}

package "Data Models" #F5F5F5 {
    entity DataFrame <<Pandas>> {
        + columns : Index
        + dtypes : Series
        + filter()
        + groupby()
        + pivot_table()
    }
    
    entity Component <<Dash>> {
        + id : str
        + children : List
        + style : dict
    }
}

' Relationships - Application Flow
FlaskApp -right-> Init : initializes

Dash *-down- DashboardLayoutManager : contains
Dash *-down- CallbackManager : contains

DashboardLayoutManager .down.> "cc_route" : registers
DashboardLayoutManager .down.> "fips_route" : registers

"cc_route" o.right.> ChartRegistry : queries
"cc_route" o.right.> FilterRegistry : queries
"cc_route" o.down.> FilterFactory : uses (lazy init)

CallbackManager o-down-> ChartRegistry : iterates

' Registry relationships
ChartRegistry o-down- "1..*" BaseChart : stores
FilterRegistry o-down- "1..*" BaseFilter : stores

' Data flow
BaseChart o-right-> EnhancedDataService : fetches data
FilterFactory o-left-> EnhancedDataService : queries metadata

' Output relationships
BaseChart .down.> Component : creates
BaseFilter .down.> Component : creates
EnhancedDataService -down-> DataFrame : provides

' Notes on implementation details
note bottom of Init
    Initialization sequence:
    1. Create EnhancedDataService with PyMongo
    2. Create ChartRegistry & FilterRegistry
    3. Instantiate and register charts
    4. Create FilterFactory (filters created on-demand)
    5. Create Dash app with use_pages=True
    6. Register routes (cc_route, fips_route)
    7. Register home page
    8. Set layout with dash.page_container
end note

note bottom of "cc_route"
    Filter to Query Flow:
    1. User interacts with filters (UI components)
    2. Dash callbacks collect filter values
    3. Filter values passed to EnhancedDataService
    4. QueryBuilder constructs MongoDB query
    5. MongoDB executes filtered query
    6. Results processed into DataFrame
    7. Charts render filtered data
end note

note top of QueryBuilder
    Query Construction Example:
    builder = QueryBuilder("cc")
    builder.add_filter("category-filter", ["OS"])
    builder.add_filter("not-valid-before-filter", "2020-01-01")
    query = builder.build()
    # {"$and": [
    #   {"category": {"$in": ["OS"]}},
    #   {"not_valid_before": {"$gte": "2020-01-01"}}
    # ]}
end note

@enduml
